<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Présentation JavaScript & React</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      .slide {
        display: none;
        min-height: 550px;
        padding: 4rem;
      }
      .slide.active {
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      pre {
        background-color: #f4f4f5;
        border-radius: 0.5rem;
        padding: 1rem;
        overflow-x: auto;
        font-size: 0.9rem;
        margin-top: 1rem;
        margin-bottom: 1rem;
        white-space: pre-wrap;
      }
      code {
        font-family: monospace;
      }
    </style>
  </head>
  <body
    class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4"
  >
    <div
      id="presentation"
      class="w-full max-w-5xl bg-white rounded-2xl shadow-2xl overflow-hidden flex flex-col"
    >
      <!-- Slides Container -->
      <div id="slides-container" class="flex-grow">
        <!-- SLIDE 1: TITRE -->
        <div class="slide text-center bg-sky-500 text-white">
          <img
            src="https://upload.wikimedia.org/wikipedia/commons/0/05/Logo_ofppt.png"
            alt="Logo OFPPT"
            class="w-32 h-32 mb-8 rounded-xl bg-white shadow-lg p-3 mx-auto border border-white/30 hover:scale-105 transition-transform duration-300"
          />

          <!-- Title -->
          <h1
            class="text-5xl font-extrabold tracking-tight drop-shadow-lg mb-3"
          >
            Développement Front-End avec React
          </h1>

          <!-- Subtitle -->
          <p class="text-2xl font-medium opacity-90 mb-6">
            Formation Interactive et Pratique
          </p>

          <!-- Trainer Info -->
          <p
            class="text-lg font-light tracking-wide bg-white/10 px-4 py-2 rounded-lg backdrop-blur-sm shadow-sm"
          >
            <span class="font-semibold text-yellow-300">Formateur :</span>
            Oussama Elhousni
          </p>
        </div>

        <!-- SLIDE 2: SÉPARATEUR JS -->
        <div class="slide text-center bg-sky-500 text-white">
          <h2 class="text-5xl font-extrabold">PARTIE 1 : JAVASCRIPT</h2>
          <p class="text-3xl mt-4">Les Fondations Essentielles du Web</p>
        </div>

        <!-- SLIDE 3: 1. INTRODUCTION À JS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            1. Introduction à JavaScript (JS)
          </h2>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              <b>Qu'est-ce que JS ?</b> Le langage de programmation du Web. Il
              rend les pages interactives.
            </li>
            <li>
              <b>Pourquoi l'apprendre ?</b> C'est indispensable pour le
              Front-end (React, Vue, Angular) et utilisé en Back-end (Node.js).
            </li>
            <li>
              <b>Où écrire du code ?</b>
              <ul class="list-circle pl-6 mt-2 space-y-1">
                <li>Balise `&lt;script&gt;` (dans HTML).</li>
                <li>
                  Fichier externe (`&lt;script
                  src="app.js"&gt;&lt;/script&gt;`).
                </li>
                <li>Console du navigateur (pour le débogage).</li>
              </ul>
            </li>
          </ul>
          <h3 class="font-semibold text-lg text-gray-800 mt-6">
            Premier programme :
          </h3>
          <pre><code>console.log("Bonjour le monde !"); // Le plus utilisé pour le débogage
alert("Attention !");            // Bloquant, à éviter en production</code></pre>
        </div>

        <!-- SLIDE 4: 2. VARIABLES ET TYPES (LET/CONST/VAR) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            2. Variables : let, const, var
          </h2>
          <div class="grid grid-cols-3 gap-4">
            <div>
              <h3 class="font-bold text-2xl text-red-500">const</h3>
              <p class="text-lg text-gray-700">
                Déclare une constante. <b>NE PEUT</b> être réassignée après
                initialisation.
              </p>
              <pre><code>const PI = 3.14; 
// PI = 3.1415; <-- ERREUR</code></pre>
            </div>
            <div>
              <h3 class="font-bold text-2xl text-blue-500">let</h3>
              <p class="text-lg text-gray-700">
                Déclare une variable avec une portée de bloc (`{}`).
                <b>PEUT</b> être réassignée.
              </p>
              <pre><code>let compteur = 0;
compteur = 1;     // OK</code></pre>
            </div>
            <div>
              <h3 class="font-bold text-2xl text-gray-500">var (À ÉVITER)</h3>
              <p class="text-lg text-gray-700">
                Déclare une variable avec une portée de fonction.
                <b>Problèmes de portée</b> (hoisting).
              </p>
              <pre><code>if (true) {
  var x = 10;
}
// console.log(x); // 10 (Fuite hors du bloc)</code></pre>
            </div>
          </div>
          <p class="text-xl text-emerald-600 font-semibold mt-4">
            ⭐ <b>Règle d'or :</b> Toujours utiliser `const` par défaut. Si vous
            devez réassigner, utilisez `let`.
          </p>
        </div>

        <!-- SLIDE 5: 2. TYPES PRIMITIFS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            2. Types de Données Primitifs
          </h2>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li><b>String :</b> Texte (ex: `"React"`).</li>
            <li>
              <b>Number :</b> Nombres entiers et décimaux (ex: `10`, `3.14`).
            </li>
            <li><b>Boolean :</b> Vrai ou Faux (ex: `true`, `false`).</li>
            <li>
              <b>Null :</b> Absence intentionnelle de valeur (ex: `let data =
              null;`).
            </li>
            <li>
              <b>Undefined :</b> Variable déclarée mais non initialisée (valeur
              par défaut).
            </li>
            <li><b>Symbol / BigInt :</b> Utilisés pour des cas avancés.</li>
          </ul>
          <h3 class="font-semibold text-lg text-gray-800 mt-6">
            Vérifier le type :
          </h3>
          <pre><code>let age = 30;
let nom = "Alice";
console.log(typeof age); // "number"
console.log(typeof nom); // "string"</code></pre>
        </div>

        <!-- SLIDE 6: 3. OPÉRATEURS DE COMPARAISON -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            3. Opérateurs de Comparaison
          </h2>
          <div class="grid grid-cols-2 gap-4">
            <div>
              <h3 class="font-bold text-2xl text-red-500">
                Double Égal (==) - Comparaison Lâche (Loose)
              </h3>
              <p class="text-lg text-gray-700">
                Compare la <b>valeur</b> en effectuant une conversion de type
                implicite.
              </p>
              <pre><code>console.log(1 == '1');   // true
console.log(0 == false); // true
console.log(null == undefined); // true</code></pre>
            </div>
            <div>
              <h3 class="font-bold text-2xl text-emerald-600">
                Triple Égal (===) - Comparaison Stricte
              </h3>
              <p class="text-lg text-gray-700">
                Compare la valeur ET le type.
                <b>Toujours utiliser ===</b> pour éviter les surprises.
              </p>
              <pre><code>console.log(1 === '1');   // false
console.log(0 === false); // false
console.log(null === undefined); // false</code></pre>
            </div>
          </div>
          <h3 class="font-semibold text-lg text-gray-800 mt-6">Autres :</h3>
          <ul class="list-disc pl-6 text-xl text-gray-700">
            <li>
              Arithmétiques : `+`, `-`, `*`, `/`, `%` (modulo), `**`
              (puissance).
            </li>
            <li>Logiques : `&&` (ET), `||` (OU), `!` (NON).</li>
            <li>
              Ternaire : `condition ? vrai : faux;` (pour les conditions
              simples).
            </li>
          </ul>
        </div>

        <!-- SLIDE 7: 4. STRUCTURES CONDITIONNELLES -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            4. Structures Conditionnelles
          </h2>
          <div class="grid grid-cols-2 gap-6">
            <div>
              <h3 class="font-bold text-2xl text-blue-500">
                if / else if / else
              </h3>
              <p class="text-lg text-gray-700">
                Pour vérifier des conditions basées sur des expressions
                booléennes.
              </p>
              <pre><code>const note = 85;
if (note > 90) {
  console.log("A");
} else if (note > 80) {
  console.log("B"); // C'est ici
} else {
  console.log("C");
}</code></pre>
            </div>
            <div>
              <h3 class="font-bold text-2xl text-purple-500">switch / case</h3>
              <p class="text-lg text-gray-700">
                Pour vérifier si une variable correspond à <b>plusieurs valeurs
                spécifiques</b>.
              </p>
              <pre><code>const jour = 'Lundi';
switch (jour) {
  case 'Samedi':
  case 'Dimanche':
    console.log("WE");
    break;
  default:
    console.log("Semaine");
}</code></pre>
            </div>
          </div>
          <p class="text-xl text-gray-600 mt-4 italic">
            Utilisez `switch` quand vous comparez une seule valeur à plusieurs
            constantes. Sinon, utilisez `if/else`.
          </p>
        </div>

        <!-- SLIDE 8: 5. BOUCLES (FOR) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            5. Boucles : for, while
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">
            La boucle `for` (itération par index)
          </h3>
          <pre><code>// 1. Initialisation (let i = 0)
// 2. Condition de continuation (i &lt; 5)
// 3. Incrémentation (i++)
for (let i = 0; i &lt; 5; i++) {
  console.log("Tour " + i);
}</code></pre>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Boucles `while` et `do...while`
          </h3>
          <pre><code>// while : la condition est vérifiée avant chaque tour
let x = 0;
while (x &lt; 3) {
  console.log("x est : " + x);
  x++;
}

// do...while : s'exécute au moins une fois
let y = 0;
do {
  console.log("y est : " + y);
} while (y &gt; 0); // La boucle s'arrête après 1 tour</code></pre>
        </div>

        <!-- SLIDE 9: 5. BOUCLES (OF/IN) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            5. Boucles : for...of et for...in
          </h2>
          <div class="grid grid-cols-2 gap-6">
            <div>
              <h3 class="font-bold text-2xl text-emerald-600">
                for...of (Valeurs)
              </h3>
              <p class="text-lg text-gray-700">
                Itère sur les <b>VALEURS</b> d'objets itérables (tableaux,
                chaînes de caractères, etc.).
              </p>
              <pre><code>const couleurs = ['rouge', 'vert', 'bleu'];
for (const couleur of couleurs) {
  console.log(couleur);
}
// Affiche : rouge, vert, bleu</code></pre>
            </div>
            <div>
              <h3 class="font-bold text-2xl text-red-600">
                for...in (Clés/Index)
              </h3>
              <p class="text-lg text-gray-700">
                Itère sur les <b>CLÉS (propriétés)</b> d'un objet.
              </p>
              <pre><code>const voiture = { marque: 'BMW', annee: 2020 };
for (const cle in voiture) {
  console.log(cle + ' : ' + voiture[cle]);
}
// Affiche : marque : BMW, annee : 2020</code></pre>
            </div>
          </div>
          <h3 class="font-semibold text-lg text-gray-800 mt-6">Contrôle :</h3>
          <pre><code>for (let i = 0; i &lt; 10; i++) {
  if (i === 3) continue; // Passe au tour suivant
  if (i === 7) break;    // Arrête la boucle
  console.log(i);
}</code></pre>
        </div>

        <!-- SLIDE 10: 6. FONCTIONS (DÉCLARATION) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">6. Fonctions</h2>
          <h3 class="font-bold text-2xl text-sky-600">Déclaration Classique</h3>
          <p class="text-lg text-gray-700">
            Blocs de code réutilisables qui peuvent prendre des
            <b>paramètres</b> et retourner une <b>valeur</b> (`return`).
          </p>
          <pre><code>function addition(a, b = 1) { // b est un paramètre par défaut
  const resultat = a + b;
  return resultat;
  // Rien après return n'est exécuté
}

const somme = addition(5, 3); // 8
const unDePlus = addition(10); // 11 (b utilise sa valeur par défaut)</code></pre>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Fonctions Anonymes
          </h3>
          <pre><code>// Utilisée souvent comme argument (callback)
document.getElementById('btn').addEventListener('click', function() {
  console.log('Clic !'); 
});</code></pre>
        </div>

        <!-- SLIDE 11: 6. FONCTIONS (FLÉCHÉES / SCOPE) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            6. Fonctions : Fléchées & Portée (Scope)
          </h2>
          <h3 class="font-bold text-2xl text-emerald-600">
            Fonctions Fléchées (Arrow Functions) - ES6
          </h3>
          <p class="text-lg text-gray-700">
            Syntaxe concise. N'a <b>pas son propre `this`</b> (très important en
            React).
          </p>
          <pre><code>// Longue
const multiplication = (a, b) => {
  return a * b;
};

// Courte (return implicite pour une seule expression)
const carre = n => n * n; </code></pre>
          <h3 class="font-bold text-2xl text-red-600 mt-4">
            Portée (Scope) des Variables
          </h3>
          <p class="text-lg text-gray-700">
            Le scope détermine où une variable est accessible.
            <b>Scope de Bloc</b> (avec `let`/`const`) est préférable.
          </p>
          <pre><code>const globalVar = 'Globale';
function maFonction() {
  const localVar = 'Locale'; // Inaccessible à l'extérieur
  console.log(globalVar); 
}</code></pre>
        </div>

        <!-- SLIDE 12: 7. TABLEAUX (BASES) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            7. Tableaux (Arrays)
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">Création et Accès</h3>
          <p class="text-lg text-gray-700">
            Les tableaux sont des listes ordonnées d'éléments (indexés à partir
            de 0).
          </p>
          <pre><code>const legumes = ['carotte', 'tomate', 'oignon'];

console.log(legumes[0]);   // Accès : 'carotte'
console.log(legumes.length); // Propriété : 3</code></pre>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Mutations (Modification du tableau original)
          </h3>
          <ul class="list-disc pl-6 space-y-1 text-lg text-gray-700">
            <li>`push(e)` : Ajoute un élément à la fin.</li>
            <li>`pop()` : Retire le dernier élément.</li>
            <li>`unshift(e)` : Ajoute un élément au début.</li>
            <li>`shift()` : Retire le premier élément.</li>
          </ul>
          <pre><code>legumes.push('pomme de terre'); // ['carotte', ..., 'pomme de terre']</code></pre>
        </div>

        <!-- SLIDE 13: 7. TABLEAUX (MÉTHODES AVANCÉES) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            7. Tableaux : Méthodes de Transformation
          </h2>
          <p class="text-xl text-gray-700 mb-4">
            Ces méthodes <b>ne modifient pas</b> le tableau original et sont
            essentielles en React (Programmation fonctionnelle).
          </p>
          <div class="grid grid-cols-3 gap-4">
            <div>
              <h3 class="font-bold text-2xl text-purple-600">.map()</h3>
              <p>
                Crée un <b>nouveau tableau</b> en appliquant une fonction à
                chaque élément.
              </p>
              <pre><code>[1, 2].map(n => n * 2); 
// [2, 4]</code></pre>
            </div>
            <div>
              <h3 class="font-bold text-2xl text-purple-600">.filter()</h3>
              <p>
                Crée un <b>nouveau tableau</b> avec les éléments qui passent un
                test (retournent `true`).
              </p>
              <pre><code>[1, 2, 3].filter(n => n &gt; 1);
// [2, 3]</code></pre>
            </div>
            <div>
              <h3 class="font-bold text-2xl text-purple-600">.reduce()</h3>
              <p>
                Exécute une fonction sur chaque élément pour produire une
                <b>seule valeur</b> (accumulateur).
              </p>
              <pre><code>[1, 2, 3].reduce((acc, n) => acc + n, 0); 
// 6</code></pre>
            </div>
          </div>
        </div>

        <!-- SLIDE 14: 8. OBJETS (BASES) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">8. Objets</h2>
          <h3 class="font-bold text-2xl text-sky-600">Création et Accès</h3>
          <p class="text-lg text-gray-700">
            Les objets sont des collections de paires clé/valeur non ordonnées
            (propriétés).
          </p>
          <pre><code>const utilisateur = {
  nom: 'Dupont',
  age: 25,
  estActif: true,
  saluer: function() { return 'Bonjour ' + this.nom; }
};

// Accès 1 (dot notation)
console.log(utilisateur.nom);  // 'Dupont'

// Accès 2 (bracket notation, utile pour les clés dynamiques)
console.log(utilisateur['age']); // 25</code></pre>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Modification / Suppression
          </h3>
          <pre><code>utilisateur.age = 26; // Modifier
delete utilisateur.estActif; // Supprimer</code></pre>
        </div>

        <!-- SLIDE 15: 8. OBJETS (MÉTHODES ET DESTRUCTURING) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            8. Objets : Méthodes Utiles & Destructuring
          </h2>
          <h3 class="font-bold text-2xl text-emerald-600">
            Méthodes de Parcours
          </h3>
          <pre><code>Object.keys(utilisateur);   // ['nom', 'age', 'saluer']
Object.values(utilisateur); // ['Dupont', 26, function...]
Object.entries(utilisateur); // [['nom', 'Dupont'], ['age', 26], ...]</code></pre>
          <h3 class="font-bold text-2xl text-emerald-600 mt-4">
            Destructuring (Démantèlement) - ES6
          </h3>
          <p class="text-lg text-gray-700">
            Extrait des valeurs d'un objet ou d'un tableau en variables
            distinctes.
          </p>
          <pre><code>const { nom, age } = utilisateur;
console.log(nom); // 'Dupont'
console.log(age); // 26

const [premiere, ...reste] = [1, 2, 3];
console.log(premiere); // 1</code></pre>
        </div>

        <!-- SLIDE 16: 9. DOM (QU'EST-CE QUE LE DOM) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            9. DOM (Document Object Model)
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">
            Qu'est-ce que le DOM ?
          </h3>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              C'est une interface de programmation pour les documents HTML et
              XML.
            </li>
            <li>
              Il représente la structure de la page comme un <b>arbre de
              nœuds</b>.
            </li>
            <li>
              JavaScript utilise le DOM pour accéder, modifier et manipuler la
              page web.
            </li>
            <li>
              <b
                >React ne manipule pas directement le DOM, il utilise le Virtual
                DOM (voir plus tard).</b
              >
            </li>
          </ul>
          <img
            src="https://placehold.co/400x150/f0f9ff/0369a1?text=Arbre+du+DOM"
            alt="Image de l'arbre du DOM"
            class="mx-auto mt-6 rounded-lg shadow-lg"
          />
        </div>

        <!-- SLIDE 17: 9. DOM (SÉLECTION ET MODIFICATION) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            9. DOM : Sélection et Contenu
          </h2>
          <h3 class="font-bold text-2xl text-emerald-600">
            Sélectionner des éléments
          </h3>
          <pre><code>// Par ID (le plus rapide)
const titre = document.getElementById('main-title'); 

// Par sélecteur CSS (le plus flexible)
const premierParagraphe = document.querySelector('.content p');
const tousLesLiens = document.querySelectorAll('a'); </code></pre>
          <h3 class="font-bold text-2xl text-emerald-600 mt-4">
            Modifier le contenu
          </h3>
          <pre><code>titre.textContent = "Nouveau Titre"; 
// Sécurisé, insère du texte simple

titre.innerHTML = "&lt;em&gt;Titre Italique&lt;/em&gt;"; 
// Peut insérer du HTML (attention à la sécurité !)</code></pre>
        </div>

        <!-- SLIDE 18: 10. ÉVÉNEMENTS (BASES) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            10. Événements : addEventListener
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">
            Qu'est-ce qu'un événement ?
          </h3>
          <p class="text-lg text-gray-700">
            Une action du navigateur ou de l'utilisateur (clic, survol,
            chargement, soumission de formulaire, touche enfoncée).
          </p>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Attacher un écouteur
          </h3>
          <pre><code>const bouton = document.querySelector('#mon-bouton');

bouton.addEventListener('click', function(event) {
  console.log('Bouton cliqué !');
  // L'objet `event` contient des informations sur l'événement
  event.preventDefault(); // Empêche l'action par défaut (ex: soumission de formulaire)
});</code></pre>
          <ul class="list-disc pl-6 space-y-1 text-lg text-gray-700 mt-4">
            <li>
              Types fréquents : `click`, `submit`, `change`, `input`,
              `mouseover`, `keydown`.
            </li>
          </ul>
        </div>

        <!-- SLIDE 19: 10. ÉVÉNEMENTS (PROPAGATION) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            10. Événements : Propagation & Délégation
          </h2>
          <h3 class="font-bold text-2xl text-red-600">
            Propagation (Bubbling)
          </h3>
          <p class="text-lg text-gray-700">
            Lorsqu'un événement se produit, il remonte du nœud cible vers la
            racine du DOM.
          </p>
          <img
            src="https://placehold.co/400x100/f0f9ff/0369a1?text=Clic+sur+Enfant+%3E+Bulle+vers+Parent"
            alt="Propagation des événements"
            class="mx-auto mt-4 rounded-lg shadow-lg"
          />
          <h3 class="font-bold text-2xl text-red-600 mt-4">
            Délégation d'Événements
          </h3>
          <p class="text-lg text-gray-700">
            Attacher un seul écouteur à un élément parent pour gérer les
            événements de tous ses enfants (même ceux ajoutés dynamiquement).
          </p>
          <pre><code>parent.addEventListener('click', function(e) {
  if (e.target.tagName === 'LI') {
    console.log('Élément de liste cliqué:', e.target.textContent);
  }
});</code></pre>
        </div>

        <!-- SLIDE 20: 11. ES6+ FEATURES -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            11. ES6+ Features (Modern JS)
          </h2>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              <b>Template Literals :</b> Chaînes de caractères avec les
              backticks (` `). Permet l'interpolation de variables.
              <pre><code>const nom = "Bob"; 
const msg = `Salut ${nom}, Bienvenue !`;</code></pre>
            </li>
            <li>
              <b>Spread Operator (...) :</b> Pour étendre un itérable
              (array/objet) en éléments individuels. Utile pour
              cloner/fusionner.
              <pre><code>const a = [1, 2];
const b = [...a, 3, 4]; // [1, 2, 3, 4]</code></pre>
            </li>
            <li>
              <b>Modules (import/export) :</b> Structure le code en fichiers
              réutilisables. Essentiel pour React.
            </li>
          </ul>
        </div>

        <!-- SLIDE 21: 12. ASYNCHRONE (BASES) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            12. Programmation Asynchrone
          </h2>
          <h3 class="font-bold text-2xl text-red-600">
            Synchrone vs Asynchrone
          </h3>
          <p class="text-lg text-gray-700">
            Le JS est par défaut <b>synchrone</b> (une ligne après l'autre).
            L'asynchrone (ex: appels API) permet aux autres tâches de s'exécuter
            pendant l'attente.
          </p>
          <h3 class="font-bold text-2xl text-red-600 mt-4">
            setTimeout et Callbacks
          </h3>
          <pre><code>// Fonction de rappel (callback) exécutée après un délai
console.log('Début');
setTimeout(() => {
  console.log('2 secondes écoulées');
}, 2000);
console.log('Fin (exécuté immédiatement)');</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            *Ceci était géré par les Callbacks (provoque le "Callback Hell").*
          </p>
        </div>

        <!-- SLIDE 22: 12. ASYNCHRONE (PROMISES, ASYNC/AWAIT) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            12. Asynchrone : Promises et async/await
          </h2>
          <h3 class="font-bold text-2xl text-emerald-600">
            Promises (Promesses)
          </h3>
          <p class="text-lg text-gray-700">
            Objet représentant l'achèvement (ou l'échec) d'une opération
            asynchrone.
          </p>
          <pre><code>fetch('/api/data')
  .then(response => response.json()) // Opération réussie
  .then(data => console.log(data))
  .catch(error => console.error(error)) // Opération échouée
  .finally(() => console.log('Terminé')); // Qu'importe le résultat</code></pre>
          <h3 class="font-bold text-2xl text-emerald-600 mt-4">
            Async/Await (ES2017)
          </h3>
          <p class="text-lg text-gray-700">
            Simplifie la syntaxe des promesses pour qu'elle ressemble à du code
            synchrone.
          </p>
          <pre><code>async function getData() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Erreur de Fetch:", error);
  }
}</code></pre>
        </div>

        <!-- SLIDE 23: SÉPARATEUR REACT -->
        <div class="slide text-center bg-sky-500 text-white">
          <h2 class="text-5xl font-extrabold">PARTIE 2 : REACT</h2>
          <p class="text-3xl mt-4">
            Développement d'Interface Utilisateur Moderne
          </p>
        </div>

        <!-- SLIDE 24: 13. INTRODUCTION À REACT -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            13. Introduction à React
          </h2>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              <b>Qu'est-ce que React ?</b> Une bibliothèque JS pour construire
              des interfaces utilisateur (UI) déclaratives.
            </li>
            <li>
              <b>Philosophie :</b> "UI = f(état)". L'UI n'est qu'une fonction de
              l'état actuel de l'application.
            </li>
            <li>
              <b>Différences avec vanilla JS :</b> React gère les mises à jour
              du DOM pour vous, vous vous concentrez sur la gestion de l'état.
            </li>
            <li>
              <b>Installation :</b> Typiquement via des outils comme Vite ou
              Next.js (remplace Create React App).
            </li>
          </ul>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">Le Virtual DOM</h3>
          <p class="text-lg text-gray-700">
            Une représentation légère du DOM réel, gardée en mémoire par React.
            Les changements sont d'abord appliqués au V-DOM, puis React calcule
            les différences (diffing) et met à jour uniquement les parties
            nécessaires du DOM réel (minimisation des opérations coûteuses).
          </p>
        </div>

        <!-- SLIDE 25: 14. JSX -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            14. JSX : Syntaxe
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">Qu'est-ce que JSX ?</h3>
          <p class="text-lg text-gray-700">
            JavaScript XML. C'est une extension de syntaxe qui permet d'écrire
            du balisage HTML directement dans les fichiers JavaScript.
          </p>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Règles et Expressions
          </h3>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              <b>Unique Parent :</b> Tout le JSX retourné doit être enveloppé
              dans un seul élément parent (ou un `&lt;&gt;&lt;/&gt;`).
            </li>
            <li>
              <b>camelCase pour Attributs :</b> Utiliser `className` au lieu de
              `class`, `htmlFor` au lieu de `for`.
            </li>
            <li>
              <b>Expressions JS :</b> Utiliser des accolades `{}` pour insérer
              du JavaScript (variables, fonctions, calculs).
            </li>
          </ul>
          <pre><code>const nom = "Jean";
const element = &lt;h1 className="titre"&gt;Bonjour, {nom.toUpperCase()}&lt;/h1&gt;;</code></pre>
        </div>

        <!-- SLIDE 26: 15. COMPOSANTS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            15. Composants Fonctionnels
          </h2>
          <h3 class="font-bold text-2xl text-emerald-600">
            Le Bloc de Construction de React
          </h3>
          <p class="text-lg text-gray-700">
            Un composant est une fonction JavaScript qui retourne du JSX. Il
            doit commencer par une <b>majuscule</b>.
          </p>
          <pre><code>// 1. Définition du Composant (Nom: 'Bouton')
function Bouton(props) {
  return (
    &lt;button onClick={props.action}&gt;
      {props.texte} 
    &lt;/button&gt;
  );
}

// 2. Utilisation dans un autre Composant
function App() {
  return (
    &lt;div&gt;
      &lt;h2&gt;Composition&lt;/h2&gt;
      &lt;Bouton texte="Cliquer ici" action={() =&gt; console.log('Clic!')} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            On compose des composants pour construire des interfaces complexes.
          </p>
        </div>

        <!-- SLIDE 27: 16. PROPS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            16. Props (Propriétés)
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">
            Passage de Données (Flux Unidirectionnel)
          </h3>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              Les props sont des <b>arguments</b> passés au composant
              fonctionnel.
            </li>
            <li>
              Elles sont <b>Immuables</b> (Read-Only). Un composant enfant ne
              doit jamais modifier ses props.
            </li>
            <li>
              <b>Destructuring des props :</b> Pratique courante pour la clarté.
            </li>
          </ul>
          <pre><code>// Avant destructuring
function Card(props) {
  return &lt;h3&gt;{props.titre}&lt;/h3&gt;;
}

// Après destructuring
function Card({ titre, contenu }) {
  return &lt;div&gt;
    &lt;h3&gt;{titre}&lt;/h3&gt;
    &lt;p&gt;{contenu}&lt;/p&gt;
  &lt;/div&gt;
}</code></pre>
        </div>

        <!-- SLIDE 28: 17. STATE (useState) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            17. State (État) : Le Hook useState
          </h2>
          <h3 class="font-bold text-2xl text-red-600">
            Qu'est-ce que l'État ?
          </h3>
          <p class="text-lg text-gray-700">
            Des données qui, lorsqu'elles changent, provoquent le
            <b>re-rendu</b> du composant (son actualisation dans le DOM).
          </p>
          <h3 class="font-bold text-2xl text-red-600 mt-4">useState Hook :</h3>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              Retourne une paire : `[valeurActuelle, fonctionDeMiseÀJour]`.
            </li>
            <li>La mise à jour du state est <b>asynchrone</b>.</li>
          </ul>
          <pre><code>import { useState } from 'react';

function Toggle() {
  const [isOn, setIsOn] = useState(false); // Valeur initiale: false

  const handleToggle = () => {
    // Utilisez une fonction de mise à jour pour des dépendances sûres
    setIsOn(prevIsOn => !prevIsOn);
  };

  return (
    &lt;button onClick={handleToggle}&gt;
      {isOn ? 'ON' : 'OFF'}
    &lt;/button&gt;
  );
}</code></pre>
        </div>

        <!-- SLIDE 29: 18. useEffect I -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            18. useEffect Hook : Effets de bord
          </h2>
          <h3 class="font-bold text-2xl text-purple-600">
            Qu'est-ce qu'un Effet de Bord ?
          </h3>
          <p class="text-lg text-gray-700">
            Toute action qui interagit avec le monde extérieur à React (appels
            API, timers, manipulation directe du DOM, gestion des abonnements).
          </p>
          <h3 class="font-bold text-2xl text-purple-600 mt-4">
            Tableau de Dépendances `[]`
          </h3>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>`useEffect(() => { ... })` : S'exécute après chaque rendu.</li>
            <li>
              `useEffect(() => { ... }, [])` : S'exécute seulement au
              <b>montage</b> (comme `componentDidMount`).
            </li>
            <li>
              `useEffect(() => { ... }, [data])` : S'exécute au montage et quand
              `data` change.
            </li>
          </ul>
          <pre><code>useEffect(() => {
  fetchData(); // Appel API
}, []); // Se lance une seule fois (après le 1er rendu)</code></pre>
        </div>

        <!-- SLIDE 30: 18. useEffect II -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            18. useEffect : La Fonction de Nettoyage (Cleanup)
          </h2>
          <h3 class="font-bold text-2xl text-red-600">Pourquoi ?</h3>
          <p class="text-lg text-gray-700">
            Pour annuler ou nettoyer les effets qui persistent après que le
            composant ait été retiré du DOM (démontage) ou avant que l'effet ne
            s'exécute à nouveau.
          </p>
          <h3 class="font-bold text-2xl text-red-600 mt-4">Exemple : Timer</h3>
          <pre><code>useEffect(() => {
  const timer = setInterval(() => {
    console.log('Tick');
  }, 1000);

  // Fonction de nettoyage
  return () => {
    clearInterval(timer); // Arrête le timer
    console.log("Cleanup effectuée");
  };
}, []);</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            Le `return` est essentiel pour éviter les fuites de mémoire (memory
            leaks).
          </p>
        </div>

        <!-- SLIDE 31: 19. ÉVÉNEMENTS DANS REACT -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            19. Gestion des Événements dans React
          </h2>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              <b>Nommage :</b> Les gestionnaires d'événements sont en camelCase
              (ex: `onClick`, `onChange`).
            </li>
            <li>
              <b>Fonction Passée :</b> On passe une fonction, pas une chaîne de
              caractères (`onClick={handleClick}`).
            </li>
            <li>
              <b>Synthetic Events :</b> React enveloppe les événements natifs
              dans un objet appelé `SyntheticEvent` qui assure une compatibilité
              multi-navigateurs.
            </li>
          </ul>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Passer des Arguments
          </h3>
          <pre><code>function List() {
  const itemId = 5;
  // Utiliser une fonction fléchée inline pour passer un argument
  return (
    &lt;button onClick={() =&gt; handleClick(itemId)}&gt;
      Supprimer l'item 5
    &lt;/button&gt;
  );
}</code></pre>
        </div>
<!-- SLIDE 26: 15. COMPOSANTS CLASSE -->
<div class="slide">
  <h2 class="text-4xl font-bold text-gray-800 mb-6">
    15. Composants Classe
  </h2>
  <h3 class="font-bold text-2xl text-emerald-600">
    Une autre façon de créer des composants React
  </h3>
  <p class="text-lg text-gray-700">
    Un composant classe est une <b>classe JavaScript</b> qui étend
    <b>React.Component</b> et contient obligatoirement une méthode
    <b>render()</b>.
  </p>
  <pre><code>import React from 'react';

class Bouton extends React.Component {
  render() {
    return (
      &lt;button onClick={this.props.action}&gt;
        {this.props.texte}
      &lt;/button&gt;
    );
  }
}

// Utilisation
class App extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;Composition&lt;/h2&gt;
        &lt;Bouton texte="Cliquer ici" action={() => console.log('Clic!')} /&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
  <p class="text-lg text-gray-500 italic mt-4">
    Les composants classe étaient la norme avant les hooks.
  </p>
</div>

<!-- SLIDE 27: 16. PROPS DANS LES COMPOSANTS CLASSE -->
<div class="slide">
  <h2 class="text-4xl font-bold text-gray-800 mb-6">
    16. Props dans les Composants Classe
  </h2>
  <h3 class="font-bold text-2xl text-sky-600">
    Accès aux données via this.props
  </h3>
  <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
    <li>
      Les props sont accessibles avec <b>this.props</b>.
    </li>
    <li>
      Elles sont <b>en lecture seule</b>.
    </li>
    <li>
      Elles sont fournies par le composant parent.
    </li>
  </ul>
  <pre><code>class Card extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h3&gt;{this.props.titre}&lt;/h3&gt;
        &lt;p&gt;{this.props.contenu}&lt;/p&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
</div>

<!-- SLIDE 28: 17. STATE DANS UN COMPOSANT CLASSE -->
<div class="slide">
  <h2 class="text-4xl font-bold text-gray-800 mb-6">
    17. State dans les Composants Classe
  </h2>
  <h3 class="font-bold text-2xl text-red-600">
    Gestion de l'état interne
  </h3>
  <p class="text-lg text-gray-700">
    Le state représente les données internes du composant.
    Une modification du state déclenche un <b>re-rendu</b>.
  </p>
  <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
    <li>Le state est initialisé dans le <b>constructor</b>.</li>
    <li>La mise à jour se fait avec <b>this.setState()</b>.</li>
  </ul>
  <pre><code>class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: false };
  }

  handleToggle = () => {
    this.setState(prevState => ({
      isOn: !prevState.isOn
    }));
  };

  render() {
    return (
      &lt;button onClick={this.handleToggle}&gt;
        {this.state.isOn ? 'ON' : 'OFF'}
      &lt;/button&gt;
    );
  }
}</code></pre>
</div>

<!-- SLIDE 29: 18. CYCLE DE VIE I -->
<div class="slide">
  <h2 class="text-4xl font-bold text-gray-800 mb-6">
    18. Cycle de Vie : Montage
  </h2>
  <h3 class="font-bold text-2xl text-purple-600">
    componentDidMount
  </h3>
  <p class="text-lg text-gray-700">
    Cette méthode est appelée <b>une seule fois</b> après le premier rendu
    du composant.
  </p>
  <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
    <li>Appels API</li>
    <li>Initialisation de timers</li>
    <li>Abonnements</li>
  </ul>
  <pre><code>class UserList extends React.Component {
  componentDidMount() {
    console.log('Composant monté');
    // fetchData();
  }

  render() {
    return &lt;div&gt;Liste des utilisateurs&lt;/div&gt;;
  }
}</code></pre>
</div>

<!-- SLIDE 30: 18. CYCLE DE VIE II -->
<div class="slide">
  <h2 class="text-4xl font-bold text-gray-800 mb-6">
    18. Cycle de Vie : Démontage
  </h2>
  <h3 class="font-bold text-2xl text-red-600">
    componentWillUnmount
  </h3>
  <p class="text-lg text-gray-700">
    Cette méthode est appelée juste avant que le composant soit retiré du DOM.
  </p>
  <p class="text-lg text-gray-700">
    Elle sert à <b>nettoyer</b> les effets actifs.
  </p>
  <pre><code>class Timer extends React.Component {
  componentDidMount() {
    this.timer = setInterval(() => {
      console.log('Tick');
    }, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
    console.log('Timer nettoyé');
  }

  render() {
    return &lt;div&gt;Timer actif&lt;/div&gt;;
  }
}</code></pre>
  <p class="text-lg text-gray-500 italic mt-4">
    Indispensable pour éviter les fuites de mémoire.
  </p>
</div>

<!-- SLIDE 31: 19. ÉVÉNEMENTS DANS LES COMPOSANTS CLASSE -->
<div class="slide">
  <h2 class="text-4xl font-bold text-gray-800 mb-6">
    19. Gestion des Événements en Classe
  </h2>
  <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
    <li>Les méthodes utilisent <b>this</b>.</li>
    <li>
      Il faut lier le contexte ou utiliser des <b>fonctions fléchées</b>.
    </li>
    <li>Les événements utilisent le camelCase.</li>
  </ul>
  <pre><code>class Counter extends React.Component {
  state = { count: 0 };

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      &lt;button onClick={this.increment}&gt;
        Compteur: {this.state.count}
      &lt;/button&gt;
    );
  }
}</code></pre>
</div>

        <!-- SLIDE 32: 20. LISTES ET KEYS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            20. Rendu de Listes et Keys
          </h2>
          <h3 class="font-bold text-2xl text-emerald-600">
            Rendre des listes avec `.map()`
          </h3>
          <p class="text-lg text-gray-700">
            En React, on utilise la méthode `.map()` pour transformer un tableau
            de données en un tableau d'éléments JSX.
          </p>
          <pre><code>const utilisateurs = [
  { id: 1, nom: 'Anna' }, 
  { id: 2, nom: 'Bob' }
];

&lt;ul&gt;
  {utilisateurs.map(user => (
    &lt;li key={user.id}&gt;{user.nom}&lt;/li&gt;
  ))}
&lt;/ul&gt;</code></pre>
          <h3 class="font-bold text-2xl text-red-600 mt-4">
            L'Importance des `key`
          </h3>
          <ul class="list-disc pl-6 space-y-1 text-lg text-gray-700">
            <li>
              La `key` aide React à identifier quels éléments ont été modifiés,
              ajoutés ou supprimés.
            </li>
            <li>
              Elle doit être <b>unique</b> et <b>stable</b> (ID de la base de
              données). N'utilisez <b>JAMAIS</b> l'index du tableau si la liste
              peut changer de manière dynamique.
            </li>
          </ul>
        </div>

        <!-- SLIDE 33: 21. FORMULAIRES CONTRÔLÉS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            21. Formulaires Contrôlés
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">Le Contrôle par React</h3>
          <p class="text-lg text-gray-700">
            Un formulaire est "contrôlé" lorsque sa valeur est gérée par le
            <b>state</b> de React.
          </p>
          <pre><code>import { useState } from 'react';

function Formulaire() {
  const [valeur, setValeur] = useState('');

  const handleChange = (event) => {
    // La valeur de l'input est toujours lue depuis l'objet event
    setValeur(event.target.value); 
  };

  return (
    &lt;input 
      type="text" 
      value={valeur} // La valeur affichée est lue depuis le state
      onChange={handleChange} // Chaque frappe met à jour le state
      placeholder="Votre nom"
    /&gt;
  );
}</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            C'est le pattern standard pour la gestion des inputs en React.
          </p>
        </div>

        <!-- SLIDE 34: STYLING EN REACT (INTRODUCTION) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            22. Styling en React
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">
            Pourquoi le styling est important ?
          </h3>
          <p class="text-lg text-gray-700">
            Le style en React détermine l’apparence visuelle de vos composants.
            Vous pouvez utiliser différentes approches selon le niveau de
            complexité et de réutilisabilité souhaité.
          </p>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700 mt-4">
            <li>
              <b>Inline Styles :</b> Style défini directement dans le JSX via un
              objet JavaScript.
            </li>
            <li>
              <b>CSS Externe :</b> Fichiers CSS globaux importés dans vos
              composants.
            </li>
            <li>
              <b>CSS Modules :</b> Styles locaux, évitent les conflits entre
              composants.
            </li>
            <li>
              <b>Bibliothèques CSS :</b> (ex : Tailwind, Bootstrap, MUI) pour
              accélérer le design.
            </li>
          </ul>
          <p class="text-xl text-emerald-600 font-semibold mt-6">
            ⭐ Le choix dépend du projet : Tailwind pour la rapidité, CSS
            Modules pour la modularité.
          </p>
        </div>

        <!-- SLIDE 35: INLINE ET CSS EXTERNE -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            23. Styling : Inline & CSS Externe
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">1️⃣ Inline Styles</h3>
          <p class="text-lg text-gray-700">
            On utilise un objet JavaScript. Les noms de propriétés utilisent le
            format camelCase.
          </p>
          <pre><code>const style = { color: "blue", fontSize: "22px" };
&lt;p style={style}&gt;Bonjour React !&lt;/p&gt;

// Exemple dynamique :
&lt;div style={{ backgroundColor: isActive ? "green" : "red" }}&gt;
  {isActive ? "Actif" : "Inactif"}
&lt;/div&gt;</code></pre>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">2️⃣ CSS Externe</h3>
          <p class="text-lg text-gray-700">
            Le style est défini dans un fichier CSS classique et importé dans le
            composant.
          </p>
          <pre><code>import "./App.css";

function App() {
  return &lt;h1 className="titre"&gt;Bienvenue dans React&lt;/h1&gt;;
}

// App.css
.titre {
  color: orange;
  text-align: center;
  font-family: Arial;
}</code></pre>
        </div>

        <!-- SLIDE 36: CSS MODULES -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            24. Styling : CSS Modules
          </h2>
          <p class="text-lg text-gray-700">
            Les <b>CSS Modules</b> permettent de créer des styles isolés pour
            chaque composant. Le nom des classes est automatiquement rendu
            unique.
          </p>
          <pre><code>import styles from "./App.module.css";

function App() {
  return (
    &lt;div className={styles.card}&gt;
      &lt;h2 className={styles.title}&gt;Carte stylée&lt;/h2&gt;
    &lt;/div&gt;
  );
}

// App.module.css
.card {
  background-color: #f0f9ff;
  border-radius: 12px;
  padding: 1rem;
}

.title {
  color: #0369a1;
}</code></pre>
          <p class="text-xl text-emerald-600 font-semibold mt-4">
            ✅ Avantage : pas de conflit de classes entre composants différents.
          </p>
        </div>

        <!-- SLIDE 37: CONTEXT API (INTRODUCTION) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            25. Context API : Introduction
          </h2>
          <p class="text-lg text-gray-700">
            Le <b>Context API</b> permet de partager des données à travers
            plusieurs composants sans passer de props à chaque niveau. On
            l’utilise souvent pour gérer :
          </p>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700 mt-2">
            <li>Le thème (clair/sombre)</li>
            <li>L’utilisateur connecté</li>
            <li>Les paramètres de langue</li>
            <li>Le panier dans une boutique</li>
          </ul>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Structure de base
          </h3>
          <pre><code>import { createContext } from "react";
export const ThemeContext = createContext("light");</code></pre>
          <p class="text-lg text-gray-700 mt-2">
            Ensuite, on utilise un <b>Provider</b> pour fournir la valeur et le
            hook <b>useContext()</b> pour la lire.
          </p>
        </div>

        <!-- SLIDE 38: CONTEXT API (UTILISATION) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            26. Context API : Fournir et Consommer
          </h2>
          <h3 class="font-bold text-2xl text-emerald-600">
            1️⃣ Fournir le contexte
          </h3>
          <pre><code>&lt;ThemeContext.Provider value="dark"&gt;
  &lt;Navbar /&gt;
&lt;/ThemeContext.Provider&gt;</code></pre>

          <h3 class="font-bold text-2xl text-emerald-600 mt-4">
            2️⃣ Consommer avec useContext
          </h3>
          <pre><code>import { useContext } from "react";
import { ThemeContext } from "./ThemeContext";

function Navbar() {
  const theme = useContext(ThemeContext);
  return &lt;h3&gt;Thème actuel : {theme}&lt;/h3&gt;;
}</code></pre>

          <p class="text-lg text-gray-700 mt-4">
            ✅ <b>Avantage :</b> évite de répéter les props inutiles.  
            ⚠️ <b>Attention :</b> chaque Provider crée un nouveau contexte
            isolé.
          </p>
        </div>

        <!-- SLIDE 39: USEREF -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            27. Hook useRef()
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">
            Qu’est-ce que useRef ?
          </h3>
          <p class="text-lg text-gray-700">
            <b>useRef()</b> permet de stocker une valeur persistante entre les
            rendus sans provoquer de re-render.
          </p>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Exemple : accéder à un élément DOM
          </h3>
          <pre><code>import { useRef } from "react";

function FocusInput() {
  const inputRef = useRef();

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    &lt;div&gt;
      &lt;input ref={inputRef} placeholder="Cliquez sur le bouton" /&gt;
      &lt;button onClick={focusInput}&gt;Focus&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
          <p class="text-lg text-gray-700 mt-3">
            💡 Aussi utile pour sauvegarder des valeurs précédentes ou un
            intervalle de temps.
          </p>
        </div>

        <!-- SLIDE 40: USEMEMO, USECALLBACK & MEMO -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            28. useMemo, useCallback et React.memo
          </h2>

          <h3 class="font-bold text-2xl text-emerald-600">1️⃣ useMemo()</h3>
          <p class="text-lg text-gray-700">
            Mémorise le résultat d’un calcul pour éviter de le refaire à chaque
            rendu.
          </p>
          <pre><code>const total = useMemo(() => {
  console.log("Calcul du total...");
  return items.reduce((sum, i) => sum + i.price, 0);
}, [items]);</code></pre>

          <h3 class="font-bold text-2xl text-emerald-600 mt-4">
            2️⃣ useCallback()
          </h3>
          <p class="text-lg text-gray-700">
            Mémorise une fonction pour éviter de la recréer à chaque rendu.
          </p>
          <pre><code>const handleClick = useCallback(() => {
  console.log("Clic !");
}, []);</code></pre>

          <h3 class="font-bold text-2xl text-emerald-600 mt-4">
            3️⃣ React.memo()
          </h3>
          <p class="text-lg text-gray-700">
            Empêche le re-rendu d’un composant si ses props n’ont pas changé.
          </p>
          <pre><code>const Enfant = React.memo(({ name }) => {
  console.log("Rendu :", name);
  return &lt;p&gt;Bonjour {name}&lt;/p&gt;;
});</code></pre>

          <p class="text-xl text-emerald-600 font-semibold mt-4">
            ✅ Idéal pour améliorer les performances dans des listes ou
            composants coûteux.
          </p>
        </div>

        <!-- SLIDE 41: USEREDUCER -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            29. Hook useReducer : gérer des états complexes
          </h2>
          <p class="text-lg text-gray-700">
            <b>useReducer</b> est une alternative à <code>useState</code> pour
            les états plus complexes (objets, multiples sous-valeurs) ou avec
            beaucoup de transitions.
          </p>
          <ul class="list-disc pl-6 space-y-2 text-xl text-gray-700 mt-4">
            <li>Basé sur le pattern <b>state + action → nouveau state</b>.</li>
            <li>Ressemble beaucoup à Redux (même logique de reducer).</li>
          </ul>
          <pre><code>import { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: 0 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    &lt;div&gt;
      &lt;p&gt;Compteur : {state.count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: "increment" })}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: "decrement" })}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: "reset" })}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            Très utile pour des formulaires complexes, des wizards, ou des
            composants avec beaucoup de règles métier.
          </p>
        </div>

        <!-- SLIDE 42: CUSTOM HOOKS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            30. Custom Hooks : réutiliser la logique
          </h2>
          <p class="text-lg text-gray-700">
            Un <b>custom hook</b> est une fonction qui commence par
            <code>use...</code> et qui permet de <b>factoriser de la logique
            React</b> (state, effets, contexte) pour la réutiliser dans
            plusieurs composants.
          </p>
          <ul class="list-disc pl-6 space-y-2 text-xl text-gray-700 mt-4">
            <li>Permet d’éviter les duplications (DRY).</li>
            <li>Peut combiner plusieurs hooks internes (useState, useEffect…).</li>
          </ul>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Exemple : hook <code>useToggle</code>
          </h3>
          <pre><code>import { useState } from "react";

function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  const toggle = () => setValue((prev) =&gt; !prev);
  return { value, toggle };
}

// Utilisation
function Switch() {
  const { value: isOn, toggle } = useToggle();

  return (
    &lt;button onClick={toggle}&gt;
      {isOn ? "ON" : "OFF"}
    &lt;/button&gt;
  );
}</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            Plus tard, on peut créer des custom hooks pour les appels API
            (<code>useFetch</code>, <code>useAuth</code>, etc.).
          </p>
        </div>

        <!-- SLIDE 43: SÉPARATEUR PARTIE 3 -->
        <div class="slide text-center bg-sky-500 text-white">
          <h2 class="text-5xl font-extrabold">
            PARTIE 3 : Navigation & Gestion d’État
          </h2>
          <p class="text-3xl mt-4">React Router DOM & Redux Toolkit</p>
        </div>

        <!-- SLIDE 44: REACT ROUTER DOM (INTRODUCTION) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            31. React Router DOM : Introduction
          </h2>
          <p class="text-lg text-gray-700">
            <b>React Router DOM</b> permet de gérer la navigation entre
            plusieurs pages dans une application
            <b>Single Page Application (SPA)</b> sans rechargement complet du
            navigateur.
          </p>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700 mt-4">
            <li><b>SPA :</b> Une seule page HTML, le contenu change selon la route.</li>
            <li><b>React Router :</b> Lie les chemins (URL) à des composants React.</li>
            <li>Supporte les <b>paramètres dynamiques</b> et la <b>navigation imbriquée</b>.</li>
          </ul>
          <p class="text-xl text-emerald-600 font-semibold mt-6">
            ⭐ Navigation fluide, sans rechargement complet.
          </p>
        </div>

        <!-- SLIDE 45: INSTALLATION & CONFIGURATION -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            32. Installation & Configuration
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">Installation :</h3>
          <pre><code>npm install react-router-dom</code></pre>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Structure de base :
          </h3>
          <pre><code>import { BrowserRouter, Routes, Route } from "react-router-dom";
import Home from "./Home";
import About from "./About";

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            💡 <code>BrowserRouter</code> enveloppe toute l’application et gère
            l’historique de navigation.
          </p>
        </div>

        <!-- SLIDE 46: NAVIGATION & LINK -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            33. Navigation avec &lt;Link&gt; et useNavigate
          </h2>
          <h3 class="font-bold text-2xl text-emerald-600">
            &lt;Link&gt; : Navigation sans rechargement
          </h3>
          <pre><code>import { Link } from "react-router-dom";

function Navbar() {
  return (
    &lt;nav&gt;
      &lt;Link to="/"&gt;Accueil&lt;/Link&gt;
      &lt;Link to="/about"&gt;À propos&lt;/Link&gt;
    &lt;/nav&gt;
  );
}</code></pre>

          <h3 class="font-bold text-2xl text-emerald-600 mt-4">
            useNavigate() : Navigation programmée
          </h3>
          <pre><code>import { useNavigate } from "react-router-dom";

function Login() {
  const navigate = useNavigate();
  const handleLogin = () =&gt; {
    navigate("/dashboard");
  };
  return &lt;button onClick={handleLogin}&gt;Se connecter&lt;/button&gt;;
}</code></pre>
        </div>

        <!-- SLIDE 47: ROUTES IMBRIQUÉES & OUTLET -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            34. Routes Imbriquées &lt;Outlet /&gt;
          </h2>
          <p class="text-lg text-gray-700">
            Les <b>routes imbriquées</b> permettent de partager un layout
            (header, sidebar…) entre plusieurs pages enfants.  
            Le composant <code>&lt;Outlet /&gt;</code> indique où le contenu
            de la route enfant sera rendu.
          </p>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            1️⃣ Déclaration des routes imbriquées
          </h3>
          <pre><code>// App.jsx
import { Routes, Route } from "react-router-dom";
import DashboardLayout from "./DashboardLayout";
import Overview from "./Overview";
import Settings from "./Settings";

function App() {
  return (
    &lt;Routes&gt;
      &lt;Route path="/dashboard" element={&lt;DashboardLayout /&gt;}&gt;
        &lt;Route index element={&lt;Overview /&gt;} /&gt;
        &lt;Route path="settings" element={&lt;Settings /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
}</code></pre>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            2️⃣ Utilisation de &lt;Outlet /&gt; dans le layout
          </h3>
          <pre><code>import { Outlet, Link } from "react-router-dom";

function DashboardLayout() {
  return (
    &lt;div&gt;
      &lt;nav&gt;
        &lt;Link to="/dashboard"&gt;Vue globale&lt;/Link&gt;
        &lt;Link to="/dashboard/settings"&gt;Paramètres&lt;/Link&gt;
      &lt;/nav&gt;

      &lt;main&gt;
        &lt;Outlet /&gt; {/* Ici s’affiche la route enfant */} 
      &lt;/main&gt;
    &lt;/div&gt;
  );
}</code></pre>
        </div>

        <!-- SLIDE 48: ROUTES DYNAMIQUES, PROTÉGÉES & useSearchParams -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            35. Routes Dynamiques, Protégées & useSearchParams
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">Paramètres dynamiques</h3>
          <pre><code>import { useParams } from "react-router-dom";

function Profil() {
  const { id } = useParams();
  return &lt;h2&gt;Profil utilisateur : {id}&lt;/h2&gt;;
}

// Déclaration
&lt;Route path="/profil/:id" element={&lt;Profil /&gt;} /&gt;</code></pre>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Lire les query params avec useSearchParams
          </h3>
          <pre><code>import { useSearchParams } from "react-router-dom";

function Products() {
  const [searchParams, setSearchParams] = useSearchParams();

  const page = searchParams.get("page") || "1";
  const category = searchParams.get("category") || "all";

  return (
    &lt;div&gt;
      &lt;h2&gt;Page : {page}&lt;/h2&gt;
      &lt;p&gt;Catégorie : {category}&lt;/p&gt;
      &lt;button onClick={() =&gt; setSearchParams({ page: "2", category })}&gt;
        Aller à la page 2
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">Routes protégées</h3>
          <pre><code>import { Navigate } from "react-router-dom";

function ProtectedRoute({ isAuth, children }) {
  return isAuth ? children : &lt;Navigate to="/login" /&gt;;
}</code></pre>
          <p class="text-lg text-gray-700 mt-3">
            🔒 On protège une route en enveloppant le composant cible dans
            <code>ProtectedRoute</code>.
          </p>
        </div>

        <!-- SLIDE 49: REDUX TOOLKIT (INTRODUCTION) -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            36. Redux Toolkit : Introduction
          </h2>
          <p class="text-lg text-gray-700">
            <b>Redux Toolkit (RTK)</b> simplifie la gestion de l’état global en
            éliminant la complexité du Redux classique.
          </p>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700 mt-4">
            <li><b>Problème :</b> Redux classique est verbeux (actions, switch...).</li>
            <li>
              <b>Solution :</b> RTK fournit
              <code>createSlice()</code> &amp; <code>configureStore()</code>.
            </li>
            <li>Permet de partager un état global entre plusieurs composants.</li>
          </ul>
          <pre class="mt-4"><code>npm install @reduxjs/toolkit react-redux</code></pre>
          <p class="text-xl text-emerald-600 font-semibold mt-6">
            ⭐ Recommandé officiellement par l’équipe Redux.
          </p>
        </div>

        <!-- SLIDE 50: CONFIGURATION COMPLÈTE DE REDUX TOOLKIT -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            37. Configuration complète de Redux Toolkit
          </h2>

          <h3 class="font-bold text-2xl text-sky-600">1️⃣ Créer un Slice</h3>
          <pre><code>// src/features/counterSlice.js
import { createSlice } from "@reduxjs/toolkit";

export const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) =&gt; { state.value += 1 },
    decrement: (state) =&gt; { state.value -= 1 },
    reset: (state) =&gt; { state.value = 0 },
  },
});

export const { increment, decrement, reset } = counterSlice.actions;
export default counterSlice.reducer;</code></pre>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            2️⃣ Configurer le Store
          </h3>
          <pre><code>// src/app/store.js
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "../features/counterSlice";

export const store = configureStore({
  reducer: { counter: counterReducer },
});</code></pre>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            3️⃣ Connecter le Store à l’Application
          </h3>
          <pre><code>// src/main.jsx
import { Provider } from "react-redux";
import { store } from "./app/store";
import App from "./App";

import ReactDOM from "react-dom/client";
ReactDOM.createRoot(document.getElementById("root")).render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;
);</code></pre>
        </div>

        <!-- SLIDE 51: UTILISATION DANS UN COMPOSANT -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            38. Utilisation de Redux Toolkit dans un composant
          </h2>
          <pre><code>import { useDispatch, useSelector } from "react-redux";
import { increment, decrement, reset } from "./features/counterSlice";

export default function Counter() {
  const count = useSelector((state) =&gt; state.counter.value);
  const dispatch = useDispatch();

  return (
    &lt;div&gt;
      &lt;h2&gt;Valeur : {count}&lt;/h2&gt;
      &lt;button onClick={() =&gt; dispatch(increment())}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch(decrement())}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch(reset())}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
          <p class="text-xl text-emerald-600 font-semibold mt-4">
            ⚡ Redux Toolkit simplifie tout le flux :
            <b>State → Action → Reducer → UI</b>
          </p>
        </div>

        <!-- SLIDE 52: BONNES PRATIQUES REDUX TOOLKIT -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            39. Bonnes Pratiques Redux Toolkit
          </h2>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>📁 Organiser vos fichiers par <b>feature</b> (slice, store, composant).</li>
            <li>
              🔄 Utiliser <code>createAsyncThunk()</code> pour les appels API
              asynchrones.
            </li>
            <li>
              🧩 Éviter de stocker des objets DOM ou fonctions dans le store
              (données sérialisables uniquement).
            </li>
            <li>🧠 Préférer les <b>selectors</b> pour lire les données du store.</li>
            <li>
              ⚙️ Utiliser <code>devTools</code> de Redux pour visualiser les
              actions et l’état.
            </li>
          </ul>
          <p class="text-xl text-emerald-600 font-semibold mt-6">
            ✅ Une bonne configuration Redux rend votre application
            <b>prévisible, scalable et débogable</b>.
          </p>
        </div>

        <!-- SLIDE 53: REDUX CLASSIQUE -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            40. Redux classique (avant Redux Toolkit)
          </h2>
          <p class="text-lg text-gray-700">
            Avant Redux Toolkit, on utilisait directement la bibliothèque
            <code>redux</code>. La logique est la même, mais plus
            <b>verbueuse</b>.
          </p>
          <ul class="list-disc pl-6 space-y-2 text-xl text-gray-700 mt-4">
            <li><b>Store :</b> contient l’état global.</li>
            <li><b>Reducer :</b> fonction pure (state, action) → nouveau state.</li>
            <li><b>Actions :</b> objets avec un type (et éventuellement un payload).</li>
          </ul>
          <pre><code>import { createStore } from "redux";

// 1️⃣ Reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + 1 };
    case "DECREMENT":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// 2️⃣ Store
const store = createStore(counterReducer);

// 3️⃣ Dispatch
store.dispatch({ type: "INCREMENT" });
console.log(store.getState()); // { count: 1 }</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            Aujourd’hui, on privilégie Redux Toolkit, mais comprendre Redux
            classique aide à lire du code legacy.
          </p>
        </div>

        <!-- SLIDE 54: PARTIE 4 APIS -->
        <div class="slide text-center bg-sky-500 text-white">
          <h2 class="text-5xl font-extrabold">
            PARTIE 4 : APIs &amp; Intégration Back-End
          </h2>
          <p class="text-3xl mt-4">
            REST, HTTP, JSON, Fetch, Axios &amp; bonnes pratiques
          </p>
        </div>

        <!-- SLIDE 55: QU'EST-CE QU'UNE API / REST -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            41. Qu’est-ce qu’une API ? Qu’est-ce qu’une REST API ?
          </h2>
          <p class="text-lg text-gray-700">
            Une <b>API (Application Programming Interface)</b> est une porte
            d’entrée permettant à un programme d’en appeler un autre pour
            récupérer ou envoyer des données.
          </p>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700 mt-4">
            <li>
              <b>API Web :</b> accessible via HTTP(s), généralement au format
              JSON.
            </li>
            <li>
              <b>REST (REpresentational State Transfer) :</b> style d’API qui
              utilise les verbes HTTP et des URLs pour manipuler des
              ressources.
            </li>
            <li>
              Une ressource peut être : <code>/users</code>,
              <code>/orders</code>, <code>/products</code>, etc.
            </li>
          </ul>
          <p class="text-xl text-emerald-600 font-semibold mt-6">
            Exemple : <code>GET https://api.example.com/users/42</code> → récupère
            l’utilisateur avec l’ID 42.
          </p>
        </div>

        <!-- SLIDE 56: VERBES HTTP & STATUTS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            42. Verbes HTTP &amp; Codes de Statut
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">Verbes principaux</h3>
          <ul class="list-disc pl-6 space-y-2 text-xl text-gray-700 mt-2">
            <li><b>GET :</b> Lire / récupérer des données.</li>
            <li><b>POST :</b> Créer une nouvelle ressource.</li>
            <li><b>PUT :</b> Remplacer complètement une ressource.</li>
            <li><b>PATCH :</b> Modifier partiellement une ressource.</li>
            <li><b>DELETE :</b> Supprimer une ressource.</li>
          </ul>
          <h3 class="font-bold text-2xl text-emerald-600 mt-6">
            Codes de statut HTTP (réponse serveur)
          </h3>
          <ul class="list-disc pl-6 space-y-2 text-xl text-gray-700 mt-2">
            <li><b>2xx :</b> Succès (200 OK, 201 Created).</li>
            <li><b>4xx :</b> Erreur côté client (400 Bad Request, 401 Unauthorized, 404 Not Found).</li>
            <li><b>5xx :</b> Erreur côté serveur (500 Internal Server Error).</li>
          </ul>
          <p class="text-lg text-gray-500 italic mt-4">
            Toujours vérifier le code de statut avant de traiter la réponse JSON.
          </p>
        </div>

        <!-- SLIDE 57: ENDPOINT, HEADERS, JSON -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            43. Endpoints, Headers, Body &amp; JSON
          </h2>
          <h3 class="font-bold text-2xl text-sky-600">1️⃣ Endpoint</h3>
          <p class="text-lg text-gray-700">
            URL d’un service précis, par exemple :
            <code>https://api.example.com/users?page=2</code>.
          </p>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">2️⃣ Headers</h3>
          <p class="text-lg text-gray-700">
            Métadonnées envoyées avec la requête/réponse :
          </p>
          <ul class="list-disc pl-6 space-y-1 text-xl text-gray-700 mt-2">
            <li><code>Content-Type: application/json</code></li>
            <li><code>Authorization: Bearer &lt;token&gt;</code></li>
          </ul>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">3️⃣ Body (corps)</h3>
          <p class="text-lg text-gray-700">
            Données envoyées dans une requête (POST/PUT/PATCH), souvent en
            <b>JSON</b>.
          </p>
          <pre><code>// Exemple de payload JSON
{
  "name": "Alice",
  "email": "alice@example.com"
}</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            JSON = JavaScript Object Notation : format léger, lisible, idéal
            pour le Web.
          </p>
        </div>

        <!-- SLIDE 58: INTEGRATION AVEC FETCH -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            44. Intégrer une API avec fetch()
          </h2>
          <p class="text-lg text-gray-700">
            <code>fetch</code> est l’API native du navigateur pour faire des
            requêtes HTTP.
          </p>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">
            Exemple : GET + gestion du chargement / erreur
          </h3>
          <pre><code>import { useEffect, useState } from "react";

function Users() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    async function loadUsers() {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/users");

        if (!res.ok) {
          throw new Error("Erreur HTTP : " + res.status);
        }

        const data = await res.json();
        setUsers(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    loadUsers();
  }, []);

  if (loading) return &lt;p&gt;Chargement...&lt;/p&gt;;
  if (error) return &lt;p&gt;Erreur : {error}&lt;/p&gt;;

  return (
    &lt;ul&gt;
      {users.map((u) =&gt; (
        &lt;li key={u.id}&gt;{u.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
        </div>

        <!-- SLIDE 59: AXIOS -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            45. Axios : bibliothèque HTTP
          </h2>
          <p class="text-lg text-gray-700">
            <b>Axios</b> est une bibliothèque populaire pour simplifier les
            appels HTTP. Elle fonctionne dans le navigateur et dans Node.js.
          </p>
          <h3 class="font-bold text-2xl text-sky-600 mt-4">Installation</h3>
          <pre><code>npm install axios</code></pre>

          <h3 class="font-bold text-2xl text-sky-600 mt-4">Exemple simple</h3>
          <pre><code>import axios from "axios";
import { useEffect, useState } from "react";

function Posts() {
  const [posts, setPosts] = useState([]);

  useEffect(() =&gt; {
    axios
      .get("https://jsonplaceholder.typicode.com/posts")
      .then((res) =&gt; setPosts(res.data))
      .catch((err) =&gt; console.error(err));
  }, []);

  return (
    &lt;ul&gt;
      {posts.slice(0, 5).map((p) =&gt; (
        &lt;li key={p.id}&gt;{p.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

          <h3 class="font-bold text-2xl text-emerald-600 mt-4">
            Client Axios réutilisable
          </h3>
          <pre><code>// apiClient.js
import axios from "axios";

export const api = axios.create({
  baseURL: "https://api.monsite.com",
  headers: {
    "Content-Type": "application/json",
  },
});</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            On peut ajouter des <b>interceptors</b> pour injecter les tokens
            d’authentification ou logger les erreurs.
          </p>
        </div>

        <!-- SLIDE 60: CUSTOM HOOK API + BONNES PRATIQUES -->
        <div class="slide">
          <h2 class="text-4xl font-bold text-gray-800 mb-6">
            46. Bonnes pratiques pour l’intégration API
          </h2>
          <ul class="list-disc pl-6 space-y-3 text-xl text-gray-700">
            <li>
              📦 <b>Isoler la logique API</b> dans des services ou custom hooks
              (<code>useApi</code>, <code>useUsers</code>…).
            </li>
            <li>
              🧠 Toujours gérer les états : <code>loading</code>,
              <code>error</code>, <code>data</code>.
            </li>
            <li>
              🔐 Ne jamais mettre de secrets (token privé, clé API sensible) dans
              le front. Utiliser un back-end ou des variables d’environnement
              côté serveur.
            </li>
            <li>
              🧪 Logguer les erreurs (console, Sentry, etc.) et afficher un
              message clair à l’utilisateur.
            </li>
            <li>
              ♻️ Utiliser des custom hooks + Redux/RTK Query ou TanStack Query
              pour la mise en cache et la synchronisation serveur.
            </li>
          </ul>

          <h3 class="font-bold text-2xl text-sky-600 mt-6">
            Exemple de custom hook simple avec Axios
          </h3>
          <pre><code>import { useEffect, useState } from "react";
import { api } from "./apiClient";

function useUsers() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    api
      .get("/users")
      .then((res) =&gt; setData(res.data))
      .catch((err) =&gt; setError(err.message))
      .finally(() =&gt; setLoading(false));
  }, []);

  return { data, loading, error };
}</code></pre>
          <p class="text-lg text-gray-500 italic mt-4">
            Ensuite, vos composants deviennent très simples : ils consomment
            juste le hook et affichent l’UI.
          </p>
        </div>
      </div>

      <!-- Navigation -->
      <div
        id="navigation"
        class="bg-gray-50 border-t border-gray-200 p-4 flex justify-between items-center"
      >
        <button
          id="prevBtn"
          class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Précédent
        </button>
        <div id="slide-counter" class="text-gray-600 text-sm font-medium"></div>
        <button
          id="nextBtn"
          class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Suivant
        </button>
      </div>

      <!-- FOOTER -->
      <footer
        class="p-3 text-center text-sm text-gray-500 bg-gray-50 border-t border-gray-200"
      >
        Fait avec ❤️ par Oussama Elhousni
      </footer>
    </div>

    <script>
      const slides = document.querySelectorAll(".slide");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const slideCounter = document.getElementById("slide-counter");
      let currentSlide = 0;
      const totalSlides = slides.length;

      function showSlide(index) {
        slides.forEach((slide, i) => {
          slide.classList.remove("active");
          if (i === index) {
            slide.classList.add("active");
          }
        });

        slideCounter.textContent = `Diapositive ${
          index + 1
        } sur ${totalSlides}`;

        prevBtn.disabled = index === 0;
        nextBtn.disabled = index === totalSlides - 1;
      }

      prevBtn.addEventListener("click", () => {
        if (currentSlide > 0) {
          currentSlide--;
          showSlide(currentSlide);
        }
      });

      nextBtn.addEventListener("click", () => {
        if (currentSlide < totalSlides - 1) {
          currentSlide++;
          showSlide(currentSlide);
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") {
          prevBtn.click();
        } else if (e.key === "ArrowRight") {
          nextBtn.click();
        }
      });

      showSlide(currentSlide);
    </script>
  </body>
</html>
